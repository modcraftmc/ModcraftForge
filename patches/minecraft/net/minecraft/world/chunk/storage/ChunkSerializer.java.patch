--- a/net/minecraft/world/chunk/storage/ChunkSerializer.java
+++ b/net/minecraft/world/chunk/storage/ChunkSerializer.java
@@ -1,5 +1,9 @@
 package net.minecraft.world.chunk.storage;
 
+import ca.starlight.common.chunk.ExtendedChunk;
+import ca.starlight.common.light.SWMRNibbleArray;
+import ca.starlight.common.light.StarLightEngine;
+import ca.starlight.common.world.ExtendedWorld;
 import com.google.common.collect.Maps;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -57,6 +61,11 @@
 public class ChunkSerializer {
    private static final Logger field_222658_a = LogManager.getLogger();
 
+   private static final int STARLIGHT_LIGHT_VERSION = 1;
+
+   private static final String UNINITIALISED_SKYLIGHT_TAG = "starlight.skylight_uninit";
+   private static final String STARLIGHT_VERSION_TAG = "starlight.light_version";
+
    public static ChunkPrimer func_222656_a(ServerWorld p_222656_0_, TemplateManager p_222656_1_, PointOfInterestManager p_222656_2_, ChunkPos p_222656_3_, CompoundNBT p_222656_4_) {
       ChunkGenerator<?> chunkgenerator = p_222656_0_.func_72863_F().func_201711_g();
       BiomeProvider biomeprovider = chunkgenerator.func_202090_b();
@@ -131,6 +140,7 @@
          ichunk = new Chunk(p_222656_0_.func_201672_e(), p_222656_3_, biomecontainer, upgradedata, iticklist, iticklist1, k1, achunksection, (p_222648_1_) -> {
             func_222650_a(compoundnbt, p_222648_1_);
          });
+         if (compoundnbt.func_74764_b("ForgeCaps")) ((Chunk)ichunk).readCapsFromNBT(compoundnbt.func_74775_l("ForgeCaps"));
       } else {
          ChunkPrimer chunkprimer = new ChunkPrimer(p_222656_3_, upgradedata, achunksection, chunkprimerticklist, chunkprimerticklist1);
          chunkprimer.func_225548_a_(biomecontainer);
@@ -143,7 +153,7 @@
 
          if (!flag && chunkprimer.func_201589_g().func_209003_a(ChunkStatus.field_222614_j)) {
             for(BlockPos blockpos : BlockPos.func_191531_b(p_222656_3_.func_180334_c(), 0, p_222656_3_.func_180333_d(), p_222656_3_.func_180332_e(), 255, p_222656_3_.func_180330_f())) {
-               if (ichunk.func_180495_p(blockpos).func_185906_d() != 0) {
+               if (ichunk.func_180495_p(blockpos).getLightValue(ichunk, blockpos) != 0) {
                   chunkprimer.func_201637_h(blockpos);
                }
             }
@@ -182,6 +192,7 @@
       }
 
       if (chunkstatus$type == ChunkStatus.Type.LEVELCHUNK) {
+         net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkDataEvent.Load(ichunk, compoundnbt, chunkstatus$type));
          return new ChunkPrimerWrapper((Chunk)ichunk);
       } else {
          ChunkPrimer chunkprimer1 = (ChunkPrimer)ichunk;
@@ -215,11 +226,62 @@
             chunkprimer1.func_205767_a(generationstage$carving, BitSet.valueOf(compoundnbt5.func_74770_j(s1)));
          }
 
-         return chunkprimer1;
+         net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkDataEvent.Load(ichunk, compoundnbt, chunkstatus$type));
+
+
+         //Startlight
+         final int minSection = -1;
+         final int maxSection = 16;
+         ChunkPrimer ret = chunkprimer1;
+
+
+         SWMRNibbleArray[] blockNibbles = StarLightEngine.getFilledEmptyLight();
+         SWMRNibbleArray[] skyNibbles = StarLightEngine.getFilledEmptyLight();
+
+
+         // start copy from from the original method
+         CompoundNBT levelTag = p_222656_4_.func_74775_l("Level");
+         boolean lit = levelTag.func_74762_e(STARLIGHT_VERSION_TAG) == STARLIGHT_LIGHT_VERSION; ret.func_217305_b(lit); // diff - override lit with our value
+         boolean canReadSky = p_222656_0_.func_201675_m().func_186058_p().func_218272_d();
+         ChunkStatus status = ChunkStatus.func_222591_a(p_222656_4_.func_74775_l("Level").func_74779_i("Status"));
+         if (lit && status.func_209003_a(ChunkStatus.field_222614_j)) { // diff - we add the status check here
+            ListNBT sections = levelTag.func_150295_c("Sections", 10);
+
+            for (int ii = 0; ii < sections.size(); ++ii) {
+               CompoundNBT sectionData = sections.func_150305_b(ii);
+               int y = sectionData.func_74771_c("Y");
+
+               if (sectionData.func_150297_b("BlockLight", 7)) {
+                  // this is where our diff is
+                  blockNibbles[y - minSection] = new SWMRNibbleArray(sectionData.func_74770_j("BlockLight").clone()); // clone for data safety
+               }
+
+               if (canReadSky) {
+                  if (sectionData.func_150297_b("SkyLight", 7)) {
+                     // we store under the same key so mod programs editing nbt
+                     // can still read the data, hopefully.
+                     // however, for compatibility we store chunks as unlit so vanilla
+                     // is forced to re-light them if it encounters our data. It's too much of a burden
+                     // to try and maintain compatibility with a broken and inferior skylight management system.
+                     skyNibbles[y - minSection] = new SWMRNibbleArray(sectionData.func_74770_j("SkyLight").clone()); // clone for data safety
+                  } else if (sectionData.func_74767_n(UNINITIALISED_SKYLIGHT_TAG)) {
+                     skyNibbles[y - minSection] = new SWMRNibbleArray();
+                  }
+               }
+            }
+         }
+         // end copy from vanilla
+
+         ((ExtendedChunk)ret).setBlockNibbles(blockNibbles);
+         ((ExtendedChunk)ret).setSkyNibbles(skyNibbles);
+
+         return ret;
       }
    }
 
    public static CompoundNBT func_222645_a(ServerWorld p_222645_0_, IChunk p_222645_1_) {
+
+
       ChunkPos chunkpos = p_222645_1_.func_76632_l();
       CompoundNBT compoundnbt = new CompoundNBT();
       CompoundNBT compoundnbt1 = new CompoundNBT();
@@ -291,15 +353,25 @@
          Chunk chunk = (Chunk)p_222645_1_;
          chunk.func_177409_g(false);
 
-         for(int k = 0; k < chunk.func_177429_s().length; ++k) {
-            for(Entity entity : chunk.func_177429_s()[k]) {
+         for(int k = 0; k < chunk.getEntityLists().length; ++k) {
+            for(Entity entity : chunk.getEntityLists()[k]) {
                CompoundNBT compoundnbt3 = new CompoundNBT();
+               try {
                if (entity.func_70039_c(compoundnbt3)) {
                   chunk.func_177409_g(true);
                   listnbt2.add(compoundnbt3);
                }
+               } catch (Exception e) {
+                  LogManager.getLogger().error("An Entity type {} has thrown an exception trying to write state. It will not persist. Report this to the mod author", entity.func_200600_R(), e);
+               }
             }
          }
+         try {
+             final CompoundNBT capTag = chunk.writeCapsToNBT();
+             if (capTag != null) compoundnbt1.func_218657_a("ForgeCaps", capTag);
+         } catch (Exception exception) {
+             LogManager.getLogger().error("A capability provider has thrown an exception trying to write state. It will not persist. Report this to the mod author", exception);
+         }
       } else {
          ChunkPrimer chunkprimer = (ChunkPrimer)p_222645_1_;
          listnbt2.addAll(chunkprimer.func_201652_l());
@@ -343,7 +415,90 @@
 
       compoundnbt1.func_218657_a("Heightmaps", compoundnbt6);
       compoundnbt1.func_218657_a("Structures", func_222649_a(chunkpos, p_222645_1_.func_201609_c(), p_222645_1_.func_201604_d()));
-      return compoundnbt;
+
+
+
+      //Startlight
+
+      final int minSection = -1;
+      final int maxSection = 16;
+      CompoundNBT ret = compoundnbt;
+      if (((ExtendedWorld)p_222645_0_).getAnyChunkImmediately(p_222645_1_.func_76632_l().field_77276_a, p_222645_1_.func_76632_l().field_77275_b) != null) {
+         return compoundnbt;
+      }
+
+      SWMRNibbleArray[] blockNibbles = ((ExtendedChunk)p_222645_1_).getBlockNibbles();
+      SWMRNibbleArray[] skyNibbles = ((ExtendedChunk)p_222645_1_).getSkyNibbles();
+
+      CompoundNBT level = ret.func_74775_l("Level");
+      boolean lit = p_222645_1_.func_217310_r();
+      // diff start - store our tag for whether light data is init'd
+      if (lit) {
+         level.func_74757_a("isLightOn", false);
+         level.func_74768_a(STARLIGHT_VERSION_TAG, STARLIGHT_LIGHT_VERSION);
+      }
+      // diff end - store our tag for whether light data is init'd
+      ChunkStatus status = ChunkStatus.func_222591_a(level.func_74779_i("Status"));
+
+      CompoundNBT[] sections = new CompoundNBT[maxSection - minSection + 1];
+
+      ListNBT sectionsStored = level.func_150295_c("Sections", 10);
+
+      for (int i = 0; i < sectionsStored.size(); ++i) {
+         CompoundNBT sectionStored = sectionsStored.func_150305_b(i);
+         int k = sectionStored.func_74771_c("Y");
+
+         // strip light data
+         sectionStored.func_82580_o("BlockLight");
+         sectionStored.func_82580_o("SkyLight");
+
+         if (!sectionStored.isEmpty()) {
+            sections[k - minSection] = sectionStored;
+         }
+      }
+
+      if (lit && status.func_209003_a(ChunkStatus.field_222614_j)) {
+         for (int i = minSection; i <= maxSection; ++i) {
+            NibbleArray blockNibble = blockNibbles[i - minSection].isAllZero() ? new NibbleArray() : blockNibbles[i - minSection].toVanillaNibble();
+            NibbleArray skyNibble = skyNibbles[i - minSection].isAllZero() ? new NibbleArray() : skyNibbles[i - minSection].toVanillaNibble();
+            if (blockNibble != null || skyNibble != null) {
+               CompoundNBT section = sections[i - minSection];
+               if (section == null) {
+                  section = new CompoundNBT();
+                  section.func_74774_a("Y", (byte)i);
+                  sections[i - minSection] = section;
+               }
+
+               if (blockNibble != null && !blockNibble.func_215655_c()) {
+                  section.func_74773_a("BlockLight", blockNibble.func_177481_a());
+               }
+
+               if (skyNibble != null) {
+                  if (skyNibble.func_215655_c()) {
+                     section.func_74757_a(UNINITIALISED_SKYLIGHT_TAG, true);
+                  } else {
+                     // we store under the same key so mod programs editing nbt
+                     // can still read the data, hopefully.
+                     // however, for compatibility we store chunks as unlit so vanilla
+                     // is forced to re-light them if it encounters our data. It's too much of a burden
+                     // to try and maintain compatibility with a broken and inferior skylight management system.
+                     section.func_74773_a("SkyLight", skyNibble.func_177481_a());
+                  }
+               }
+            }
+         }
+      }
+
+      // rewrite section list
+      sectionsStored.clear();
+      for (CompoundNBT section : sections) {
+         if (section != null) {
+            sectionsStored.add(section);
+         }
+      }
+      level.func_218657_a("Sections", sectionsStored);
+
+      return ret;
    }
 
    public static ChunkStatus.Type func_222651_a(@Nullable CompoundNBT p_222651_0_) {
