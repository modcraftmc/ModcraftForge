--- a/net/minecraft/util/math/shapes/VoxelShapes.java
+++ b/net/minecraft/util/math/shapes/VoxelShapes.java
@@ -3,6 +3,7 @@
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.math.DoubleMath;
 import com.google.common.math.IntMath;
+import fr.modcraftmc.forge.tuinity.AABBVoxelShape;
 import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
 import it.unimi.dsi.fastutil.doubles.DoubleList;
 import java.util.Arrays;
@@ -22,20 +23,83 @@
 import net.minecraftforge.api.distmarker.OnlyIn;
 
 public final class VoxelShapes {
-   private static final VoxelShape field_197887_b = Util.func_199748_a(() -> {
+   public static final VoxelShape field_197887_b = Util.func_199748_a(() -> {
       VoxelShapePart voxelshapepart = new BitSetVoxelShapePart(1, 1, 1);
       voxelshapepart.func_199625_a(0, 0, 0, true, true);
       return new VoxelShapeCube(voxelshapepart);
    });
    public static final VoxelShape field_216389_a = func_197873_a(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
-   private static final VoxelShape field_197886_a = new VoxelShapeArray(new BitSetVoxelShapePart(0, 0, 0), (DoubleList)(new DoubleArrayList(new double[]{0.0D})), (DoubleList)(new DoubleArrayList(new double[]{0.0D})), (DoubleList)(new DoubleArrayList(new double[]{0.0D})));
+   public static final VoxelShape field_197886_a = new VoxelShapeArray(new BitSetVoxelShapePart(0, 0, 0), (DoubleList)(new DoubleArrayList(new double[]{0.0D})), (DoubleList)(new DoubleArrayList(new double[]{0.0D})), (DoubleList)(new DoubleArrayList(new double[]{0.0D})));
 
    public static VoxelShape func_197880_a() {
       return field_197886_a;
    }
 
+   // Tuinity start - optimise voxelshapes
+   public static boolean isEmpty(VoxelShape voxelshape) {
+      // helper function for determining empty shapes fast
+      return voxelshape == field_197886_a || voxelshape.func_197766_b();
+   }
+   // Tuinity end - optimise voxelshapes
+
+   static final AABBVoxelShape optimisedFullCube = new AABBVoxelShape(new AxisAlignedBB(0, 0, 0, 1.0, 1.0, 1.0)); // Tuinity - optimise voxelshape
+
+   // Tuinity start - optimise voxelshapes
+   public static void addBoxesToIfIntersects(VoxelShape shape, AxisAlignedBB aabb, java.util.List<AxisAlignedBB> list) {
+      if (shape instanceof AABBVoxelShape) {
+         AABBVoxelShape shapeCasted = (AABBVoxelShape)shape;
+         if (shapeCasted.aabb.voxelShapeIntersect(aabb)) {
+            list.add(shapeCasted.aabb);
+         }
+      } else if (shape instanceof VoxelShapeArray) {
+         VoxelShapeArray shapeCasted = (VoxelShapeArray)shape;
+         // this can be optimised by checking an "overall shape" first, but not needed
+
+         double offX = shapeCasted.offsetX;
+         double offY = shapeCasted.offsetY;
+         double offZ = shapeCasted.offsetZ;
+
+         for (AxisAlignedBB boundingBox : shapeCasted.boundingBoxesRepresentation) {
+            double minX, minY, minZ, maxX, maxY, maxZ;
+            if (aabb.voxelShapeIntersect(minX = boundingBox.field_72340_a + offX, minY = boundingBox.field_72338_b + offY, minZ = boundingBox.field_72339_c + offZ,
+                    maxX = boundingBox.field_72336_d + offX, maxY = boundingBox.field_72337_e + offY, maxZ = boundingBox.field_72334_f + offZ)) {
+               list.add(new AxisAlignedBB(minX, minY, minZ, maxX, maxY, maxZ));
+            }
+         }
+      } else {
+         java.util.List<AxisAlignedBB> boxes = shape.func_197756_d();
+         for (int i = 0, len = boxes.size(); i < len; ++i) {
+            AxisAlignedBB box = boxes.get(i);
+            if (box.voxelShapeIntersect(aabb)) {
+               list.add(box);
+            }
+         }
+      }
+   }
+
+   public static void addBoxesTo(VoxelShape shape, java.util.List<AxisAlignedBB> list) {
+      if (shape instanceof AABBVoxelShape) {
+         AABBVoxelShape shapeCasted = (AABBVoxelShape)shape;
+         list.add(shapeCasted.aabb);
+      } else if (shape instanceof VoxelShapeArray) {
+         VoxelShapeArray shapeCasted = (VoxelShapeArray)shape;
+
+         for (AxisAlignedBB boundingBox : shapeCasted.boundingBoxesRepresentation) {
+            list.add(boundingBox.func_72317_d(shapeCasted.offsetX, shapeCasted.offsetY, shapeCasted.offsetZ));
+         }
+      } else {
+         java.util.List<AxisAlignedBB> boxes = shape.func_197756_d();
+         for (int i = 0, len = boxes.size(); i < len; ++i) {
+            AxisAlignedBB box = boxes.get(i);
+            list.add(box);
+         }
+      }
+   }
+   // Tuinity end - optimise voxelshapes
+
+
    public static VoxelShape func_197868_b() {
-      return field_197887_b;
+      return optimisedFullCube;
    }
 
    public static VoxelShape func_197873_a(double p_197873_0_, double p_197873_2_, double p_197873_4_, double p_197873_6_, double p_197873_8_, double p_197873_10_) {
@@ -132,6 +196,20 @@
       }
    }
 
+   public static boolean applyOperation(VoxelShape voxelshape, VoxelShape voxelshape1, IBooleanFunction operatorboolean) {
+      // Tuinity start - optimise voxelshape
+      if (operatorboolean == IBooleanFunction.field_223238_i_) {
+         if (voxelshape instanceof AABBVoxelShape && voxelshape1 instanceof AABBVoxelShape) {
+            return ((AABBVoxelShape)voxelshape).aabb.voxelShapeIntersect(((AABBVoxelShape)voxelshape1).aabb);
+         } else if (voxelshape instanceof AABBVoxelShape && voxelshape1 instanceof VoxelShapeArray) {
+            return ((VoxelShapeArray)voxelshape1).intersects(((AABBVoxelShape)voxelshape).aabb);
+         } else if (voxelshape1 instanceof AABBVoxelShape && voxelshape instanceof VoxelShapeArray) {
+            return ((VoxelShapeArray)voxelshape).intersects(((AABBVoxelShape)voxelshape1).aabb);
+         }
+      }
+      return func_197879_c(voxelshape, voxelshape1, operatorboolean);
+   }
+
    public static boolean func_197879_c(VoxelShape p_197879_0_, VoxelShape p_197879_1_, IBooleanFunction p_197879_2_) {
       if (p_197879_2_.apply(false, false)) {
          throw (IllegalArgumentException)Util.func_229757_c_(new IllegalArgumentException());
@@ -145,7 +223,12 @@
          boolean flag = p_197879_2_.apply(true, false);
          boolean flag1 = p_197879_2_.apply(false, true);
 
-         for(Direction.Axis direction$axis : AxisRotation.field_197521_d) {
+         Direction.Axis[] aenumdirection_enumaxis = AxisRotation.field_197521_d;
+         int i = aenumdirection_enumaxis.length;
+
+         for (int j = 0; j < i; ++j) {
+            Direction.Axis direction$axis = aenumdirection_enumaxis[j];
+
             if (p_197879_0_.func_197758_c(direction$axis) < p_197879_1_.func_197762_b(direction$axis) - 1.0E-7D) {
                return flag || flag1;
             }
