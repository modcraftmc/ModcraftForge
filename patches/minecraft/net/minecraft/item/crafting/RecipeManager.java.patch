--- a/net/minecraft/item/crafting/RecipeManager.java
+++ b/net/minecraft/item/crafting/RecipeManager.java
@@ -19,6 +19,8 @@
 import java.util.Map.Entry;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
+
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
 import net.minecraft.client.resources.JsonReloadListener;
 import net.minecraft.inventory.IInventory;
 import net.minecraft.item.ItemStack;
@@ -40,6 +42,10 @@
    private static final Logger field_199521_c = LogManager.getLogger();
    private Map<IRecipeType<?>, Map<ResourceLocation, IRecipe<?>>> field_199522_d = ImmutableMap.of();
    private boolean field_199523_e;
+   // Yatopia start
+   private static final List<IRecipe<?>> ALL_RECIPES_CACHE = new java.util.ArrayList<>();
+   private static final Map<IRecipeType<?>, List<IRecipe<?>>> TYPES_CACHE = new Object2ObjectLinkedOpenHashMap<>();
+   // Yatopia end
 
    public RecipeManager() {
       super(field_223401_a, "recipes");
@@ -47,45 +53,94 @@
 
    protected void func_212853_a_(Map<ResourceLocation, JsonElement> p_212853_1_, IResourceManager p_212853_2_, IProfiler p_212853_3_) {
       this.field_199523_e = false;
-      Map<IRecipeType<?>, Builder<ResourceLocation, IRecipe<?>>> map = Maps.newHashMap();
+      Map<IRecipeType<?>, Object2ObjectLinkedOpenHashMap<ResourceLocation, IRecipe<?>>> map = Maps.newHashMap();
 
       for(Entry<ResourceLocation, JsonElement> entry : p_212853_1_.entrySet()) {
          ResourceLocation resourcelocation = entry.getKey();
+         if (resourcelocation.func_110623_a().startsWith("_")) continue; //Forge: filter anything beginning with "_" as it's used for metadata.
 
          try {
+            if (entry.getValue().isJsonObject() && !net.minecraftforge.common.crafting.CraftingHelper.processConditions(entry.getValue().getAsJsonObject(), "conditions")) {
+               field_199521_c.debug("Skipping loading recipe {} as it's conditions were not met", resourcelocation);
+               continue;
+            }
             IRecipe<?> irecipe = func_215377_a(resourcelocation, JSONUtils.func_151210_l(entry.getValue(), "top element"));
+            if (irecipe == null) {
+               field_199521_c.info("Skipping loading recipe {} as it's serializer returned null", resourcelocation);
+               continue;
+            }
             map.computeIfAbsent(irecipe.func_222127_g(), (p_223391_0_) -> {
-               return ImmutableMap.builder();
+               return new Object2ObjectLinkedOpenHashMap<>();
             }).put(resourcelocation, irecipe);
          } catch (IllegalArgumentException | JsonParseException jsonparseexception) {
-            field_199521_c.error("Parsing error loading recipe {}", resourcelocation, jsonparseexception);
+            //LOGGER.error("Parsing error loading recipe {}", resourcelocation, jsonparseexception);
          }
       }
 
-      this.field_199522_d = map.entrySet().stream().collect(ImmutableMap.toImmutableMap(Entry::getKey, (p_223400_0_) -> {
+      // Yatopia start - nuke stream & cache all recipes for constant access in b()
+        /*
+      this.recipes = map.entrySet().stream().collect(ImmutableMap.toImmutableMap(Entry::getKey, (p_223400_0_) -> {
          return p_223400_0_.getValue().build();
       }));
+      */
+      this.field_199522_d = ImmutableMap.copyOf(map);
+      for (Object2ObjectLinkedOpenHashMap<ResourceLocation, IRecipe<?>> recipesMap : map.values()) {
+         ALL_RECIPES_CACHE.addAll(recipesMap.values());
+      }
+      // Yatopia end
+
       field_199521_c.info("Loaded {} recipes", (int)map.size());
    }
 
    public <C extends IInventory, T extends IRecipe<C>> Optional<T> func_215371_a(IRecipeType<T> p_215371_1_, C p_215371_2_, World p_215371_3_) {
-      return this.func_215366_a(p_215371_1_).values().stream().flatMap((p_215372_3_) -> {
-         return Util.func_215081_a(p_215371_1_.func_222148_a(p_215372_3_, p_215371_3_, p_215371_2_));
+      /*
+      return this.getRecipes(recipeTypeIn).values().stream().flatMap((p_215372_3_) -> {
+         return Util.streamOptional(recipeTypeIn.matches(p_215372_3_, worldIn, inventoryIn));
       }).findFirst();
+       */
+
+      // Yatopia start - replace stream
+      Collection<IRecipe<C>> allTypes = this.func_215366_a(p_215371_1_).values();
+      Optional<T> recipe = Optional.empty();
+
+      for (IRecipe<C> possible : allTypes) {
+         Optional<T> possibleRecipe = p_215371_1_.func_222148_a(possible, p_215371_3_, p_215371_2_);
+         if (possibleRecipe.isPresent()) {
+            recipe = possibleRecipe;
+            break;
+         }
+      }
+      return recipe;
+      // Yatopia end
    }
 
    public <C extends IInventory, T extends IRecipe<C>> List<T> func_241447_a_(IRecipeType<T> p_241447_1_) {
-      return this.func_215366_a(p_241447_1_).values().stream().map((p_241453_0_) -> {
+      /*
+      return this.getRecipes(recipeType).values().stream().map((p_241453_0_) -> {
          return (T) p_241453_0_;
       }).collect(Collectors.toList());
+       */
+
+      return (List) TYPES_CACHE.computeIfAbsent(p_241447_1_, recipes1 -> new me.jellysquid.mods.lithium.common.util.collections.HashedList<>(new java.util.ArrayList<>(func_215366_a(p_241447_1_).values())));
+
+
    }
 
    public <C extends IInventory, T extends IRecipe<C>> List<T> func_215370_b(IRecipeType<T> p_215370_1_, C p_215370_2_, World p_215370_3_) {
-      return this.func_215366_a(p_215370_1_).values().stream().flatMap((p_215380_3_) -> {
-         return Util.func_215081_a(p_215370_1_.func_222148_a(p_215380_3_, p_215370_3_, p_215370_2_));
+      /*
+      return this.getRecipes(recipeTypeIn).values().stream().flatMap((p_215380_3_) -> {
+         return Util.streamOptional(recipeTypeIn.matches(p_215380_3_, worldIn, inventoryIn));
       }).sorted(Comparator.comparing((p_215379_0_) -> {
-         return p_215379_0_.func_77571_b().func_77977_a();
+         return p_215379_0_.getRecipeOutput().getTranslationKey();
       })).collect(Collectors.toList());
+       */
+      List<T> ret = new java.util.ArrayList<>();
+      for (IRecipe<C> recipe : this.func_215366_a(p_215370_1_).values()) {
+         p_215370_1_.func_222148_a(recipe, p_215370_3_, p_215370_2_).ifPresent(ret::add);
+      }
+      ret.sort(Comparator.comparing(recipe -> recipe.func_77571_b().func_77977_a()));
+      return ret;
+      // Yatopia end
    }
 
    private <C extends IInventory, T extends IRecipe<C>> Map<ResourceLocation, IRecipe<C>> func_215366_a(IRecipeType<T> p_215366_1_) {
@@ -108,15 +163,30 @@
    }
 
    public Optional<? extends IRecipe<?>> func_215367_a(ResourceLocation p_215367_1_) {
-      return this.field_199522_d.values().stream().map((p_215368_1_) -> {
-         return p_215368_1_.get(p_215367_1_);
+      /*
+      return this.recipes.values().stream().map((p_215368_1_) -> {
+         return p_215368_1_.get(recipeId);
       }).filter(Objects::nonNull).findFirst();
+
+       */
+      for (Map<ResourceLocation, IRecipe<?>> map : field_199522_d.values()) {
+         IRecipe<?> recipe = map.get(p_215367_1_);
+         if (recipe != null) {
+            return Optional.of(recipe);
+         }
+      }
+      return Optional.empty();
    }
 
    public Collection<IRecipe<?>> func_199510_b() {
-      return this.field_199522_d.values().stream().flatMap((p_215376_0_) -> {
+      /*
+      return this.recipes.values().stream().flatMap((p_215376_0_) -> {
          return p_215376_0_.values().stream();
       }).collect(Collectors.toSet());
+
+       */
+
+      return ALL_RECIPES_CACHE;
    }
 
    public Stream<ResourceLocation> func_215378_c() {
